@startuml name
Being <|-- LittleGuy
ICapitalisticActive <|.. LittleGuy : implements
ISociable <|.. LittleGuy : implements

Being +-- Narrator

object ponchik
object piluylkin
object neznayka

LittleGuy <|-- ponchik
LittleGuy <|-- piluylkin
LittleGuy <|-- neznayka

object borscht
object porridge
object salt
Eatable <|-- borscht
Eatable <|-- porridge
Eatable <|-- salt

ICapitalisticPassive <|.. Container : implements
ICapitalisticPassive <|.. Eatable : implements

IMeasurable <|.. Eatable : implements
IMeasurable <|.. Container : implements

Container <|-- Bowl
Container <|-- Table
Container <|-- Rocket

Rocket +-- Motor

ILocatable <|.. Rocket : implements
ILocatable <|.. Being : implements

Location <|-- Moon
Location <|-- Underground
Location <|-- Town
Town <|-- LosPaganos
Location <|-- Cave

static class Narrator { 
   {static} +void say(message: String)
}

class LittleGuy {
   -dutyName: String
   +LittleGuy(name)
}

enum State {
   NORMAL
   SHOCKED
   UNCONSCIOUS
}

interface ICapitalisticPassive {
   DEFAULT_COST: float
   +ICapitalisticActive getOwner()
   +float cost()
   +void sell()
}

interface ICapitalisticActive {
   +float getBalance()
   #void setBalace(balance: float)
   +String getDuty()
   +void setDuty(duty: Duty)
   +void work()
   +void sell(obj: ICapitalisticPassive)
   +void buy(obj: ICapitalisticPassive)
}

interface ISociable {
   +void say(text: String)
   +void addSocialStatus(obj: SocialStatus)
   +List<SocialStatus> getSocialStatuses()
}

abstract class Being {
   -name: String
   -type: String
   -hunger: byte
   -location: Location
   -state: State
   +Being()
   +Being(name: String, type: String)
   +void eat(obj: Eatable)
   +void eat(obj: Eatable, eatingSpeed: byte)
   +void eatIterative(obj: Container)
   +void eatIterative(obj: Container, eatingSpeed: byte)
   +void setState(state: State)
   +void use(obj: Container)
   +void unuse(obj: Container)
   #void addHunger(byte hunger)
   #void subHunger(byte hunger)
   ' to do something
}

class Eatable << (R,#FF7700) >> {
   -name: String
   -saturation: byte
   -cost: float
   +Eatable(name: String, saturation: byte)
   +Eatable(name: String, saturation: byte, cost: float)
}

class Duty << (R,#FF7700) >> {
   -name: String
   -wage: float
   -days: int
   +Duty(name: String, wage: float, days: int)
}

class SocialStatus << (R,#FF7700) >> {
   -name: String
   -organization: SocialOrganization
   +SocialStatus(name: String, organization: SocialOrganization)
}

class SocialOrganization << (R,#FF7700) >> {
   -name: String
   +SocialOrganization(name: String)
}

abstract class Container {
   -spaceLeft: float
   +Container()
   +Container(name)
   +void addItem(obj: IMeasurable)
   +List<IMeasurable> getItemList()
   +void delItem(obj: IMeasurable)
   +float getSize()
   +void empty()
}

class Motor {
   +void start()
   +void stop()
   +boolean getState()
}

class Table {
   +Table()
}

class Bowl {
   +Bowl()
}

class Rocket {
   +Rocket()
}

class Moon {
   +Moon()
}

class Town {
   +Town()
}

class LosPaganos {
   +LosPaganos()
}

class Underground {
   +Underground()
}

class Cave {
   +Cave()
}

abstract class Location {
   -name: String
   -List<> visitors: Being
   +Location(name)
   +void setParent(obj: Location)
   +String getParent()
   +String getAddress()
   +void addVisitor(obj: Being)
   +void delVisitor(obj: Being)
   +List<> getVisitors()
}

interface IMeasurable {
   +boolean canFit(size: float)
}

interface ILocatable {
   +Location getLocation()
   +void setLocation(obj: Location)
}
@enduml

' make size attribute to define whether the item can be keepable in the Container or not