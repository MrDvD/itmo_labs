@startuml name
Being <|-- LittleGuy
ICapitalisticActive <|.. LittleGuy : implements
ICapitalisticActive <|.. ICapitalisticPassive : sell()

Being <|.. Container : eatIterative()
Being <|.. Eatable : eat()

object ponchik
object piluylkin
object neznayka

LittleGuy <|-- ponchik
LittleGuy <|-- piluylkin
LittleGuy <|-- neznayka

object borscht
object porridge
object salt
Eatable <|-- borscht
Eatable <|-- porridge
Eatable <|-- salt

ICapitalisticPassive <|.. Container : implements
ICapitalisticPassive <|.. Eatable : implements

IMeasurable <|.. Eatable : implements
IMeasurable <|.. Container : implements
IWeightable <|.. Being : implements

Container <|-- Bowl
Container <|-- Table
Container <|.. IMeasurable : addItem()
Container <|.. IWeightable : addItem()

Being <|.. Place : refers
Place <|.. Being : contained
Place <|-- Planet

Planet <|-- Moon
Moon <|-- Underground
Moon <|-- LosPaganos

Effect <|.. Being : refers

class LittleGuy {
   -dutyName: String
   +LittleGuy(name)
}

enum Effect {
   NORMAL
   SHOCKED
}

interface ICapitalisticPassive {
   DEFAULT_COST: float
   +void sell()
   +float cost()
}
interface ICapitalisticActive {
   +float getBalance()
   +String getDuty()
   +void setDuty(duty)
   +void sell(obj)
}

abstract class Being {
   -name: String
   -type: String
   -hunger: byte
   -location: Place
   -effect: Effect
   Being()
   Being(name, type)
   +void setEffect(effect)
   +void eat(obj)
   +void eat(obj, eatingSpeed)
   +void eatIterative(obj)
   +void eatIterative(obj, eatingSpeed)
   +void force()
   ' to do something
}

class Eatable << (R,#FF7700) >> {
   -name: String
   -saturation: byte
   -cost: float
   +Eatable(name, saturation)
   +Eatable(name, saturation, cost)
}

abstract class Container {
   -spaceLeft: float
   Container()
   Container(name)
   +void addItem(obj: IMeasurable)
   +void addItem(obj: IWeightable)
   +float getSize()
   +void empty()
}

class Table {
   +Table()
}

class Bowl {
   +Bowl()
}

abstract class Place {
   -name: String
   -visitors[]: Being
   +String getAddress()
   ' get address recursively: super().address() + ',' + this.name
}

interface IMeasurable {
   +boolean canFit(size: float)
}

interface IWeightable {
   +boolean canWithstand(weight: float)
}
@enduml

' make size attribute to define whether the item can be keepable in the Container or not