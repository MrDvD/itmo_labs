@startuml name
Being <|-- LittleGuy
ICapitalisticActive <|.. LittleGuy : implements
ISociable <|.. LittleGuy : implements

Being +-- Log

object ponchik
object piluylkin
object neznayka

LittleGuy <|-- ponchik
LittleGuy <|-- piluylkin
LittleGuy <|-- neznayka

object borscht
object porridge
object salt
Eatable <|-- borscht
Eatable <|-- porridge
Eatable <|-- salt

ICapitalisticPassive <|.. Container : implements
ICapitalisticPassive <|.. Eatable : implements

IMeasurable <|.. Eatable : implements
IMeasurable <|.. Container : implements
IMeasurable <|.. Being : implements

Container <|-- Bowl
Container <|-- Table
Container <|-- Chair

Table +-- Chair
ISeatable <|-- Chair

Transport <|-- Rocket
Transport +-- Seat
ISeatable <|-- Seat

Rocket +-- LuggageSection
Container <|-- LuggageSection

ILocatable <|.. Transport : implements
ILocatable <|.. Being : implements

Location <|-- Moon
Location <|-- Planet
Location <|-- Underground
Location <|-- Town
Location <|-- Cave

static class Log { 
   {static} +void println(message: String)
}

class LittleGuy {
   -dutyName: String
   -balance: float
   -socialStatuses: List<SocialStatus>
   +LittleGuy(name)
}

enum State {
   NORMAL
   SHOCKED
   UNCONSCIOUS
}

interface ICapitalisticPassive {
   DEFAULT_COST: float
   PRICELESS: float
   +ICapitalisticActive getOwner()
   +float cost()
}

interface ICapitalisticActive {
   +float getBalance()
   +void setBalace(balance: float)
   +Duty getDuty()
   +void setDuty(duty: Duty)
   +void work()
   +void sell(obj: ICapitalisticPassive)
   +void buy(obj: ICapitalisticPassive)
}

interface ISeatable {
   +boolean inUse()
   +void setState(state: boolean)
   +double getSize()
}

interface ISociable {
   +void say(text: String)
   +void addSocialStatus(obj: SocialStatus)
   +void popSocialStatus()
   +List<SocialStatus> getSocialStatusList()
}

abstract class Being {
   -name: String
   -type: String
   -hunger: byte
   -location: Location
   -state: State
   #Being(name: String, type: String, size: double)
   +void eat(obj: Eatable)
   +void eat(obj: Eatable, eatingSpeed: byte)
   +void eatIterative(obj: Container)
   +void eatIterative(obj: Eatable)
   +void eatIterative(obj: IMeasurable)
   +void eatIterative(obj: Container, eatingSpeed: byte)
   +void eatIterative(obj: Eatable, eatingSpeed: byte)
   +void eatIterative(obj: IMeasurable, eatingSpeed: byte)
   +void setState(state: State)
   +void use(obj: Container)
   +void unuse(obj: Container)
   #void addHunger(byte hunger)
   #void subHunger(byte hunger)
}

class Eatable << (R,#FF7700) >> {
   -name: String
   -saturation: byte
   -cost: float
   +Eatable(name: String, saturation: byte)
   +Eatable(name: String, saturation: byte, cost: float)
}

class Duty << (R,#FF7700) >> {
   -name: String
   -wage: float
   -days: int
   +Duty(name: String, wage: float, days: int)
}

class SocialStatus << (R,#FF7700) >> {
   -name: String
   -organization: SocialOrganization
   +SocialStatus(name: String, organization: SocialOrganization)
}

class SocialOrganization << (R,#FF7700) >> {
   -name: String
   +SocialOrganization(name: String)
}

abstract class Transport {
   -name: String
   -environment: Environment
   -maxPassengerCount: int
   -currPassengerCount: int
   -maxPassengerSize: double
   -passengers: List<Being>
   #Transport(name: String, environment: Environment, maxPassengerCount: int, maxPassengerSize: double)
   +void addPassenger(obj: Being)
   +void popPassenger()
   +List<Being> getPassengerList()
}

abstract class Container {
   -name: String
   -size: double
   -spaceLeft: double
   -cost: float
   +Container(name: String, size: double)
   +Container(name: String, size: double, cost: float)
   +void addItem(obj: IMeasurable)
   +void delItem(obj: IMeasurable)
   +List<IMeasurable> getItemList()
   +void empty()
}

class Table {
   +Table(size: double)
   +Table(size: double, cost: float)
   +initChairs(num: int, size: double)
   +Chair getFreeChair()
}

class Chair {
   -size: double
   -inUse: boolean
   +Chair(size: double)
}

class Bowl {
   +Bowl()
}

class LuggageSection {
   +LuggageSection()
}

class Rocket {
   -luggage: LuggageSection
   +Rocket(name: String, location: Location)
   +LuggageSection getLuggage();
}

class Moon {
   +Moon()
}

class Planet {
   +Planet()
   +Planet(name: String)
}

class Town {
   +Town()
   +Town(name: String)
}

class Underground {
   +Underground()
}

class Cave {
   +Cave()
}

abstract class Location {
   -name: String
   -parent: Location
   -List<> visitorList: Being
   -environment: List<Environment>
   #Location(name)
   +void setParent(obj: Location)
   +String getParent()
   +String getAddress()
   +void addVisitor(obj: Being)
   +void delVisitor(obj: Being)
   +List<Being> getVisitorList()
}

interface IMeasurable {
   +boolean canFit(size: double)
   +double getSize()
}

interface ILocatable {
   +Location getLocation()
   +void setLocation(obj: Location)
   +boolean isReachable(obj: Location)
}
@enduml

' make size attribute to define whether the item can be keepable in the Container or not