          ORG   0x20
RESWRDS:  WORD  0x4       ; result's word capacity (recalculate INFTY if you change it!)
RESADDR:  WORD  0x400     ; result's starting word address
INFTY:    WORD  22        ; upper bound of FACT's function arguments
INPUT:    WORD  12        ; FACT's input argument

START:    LD    INPUT     ; main()
          PUSH
          LD    RESADDR
          PUSH
          LD    RESWRDS
          PUSH
          CALL  FACT
          HLT

FACT:     LD    &3        ; FACT(uint16_t number, uint16_t* result, uint16_t result_size)
          CMP   #2
          BCC   BASE
          CMP   INFTY
          BCS   OFW
          DEC             ; FACT call (recursive)
          PUSH
          LD    &3
          PUSH
          LD    &3
          PUSH
          CALL  FACT
          LD    &3        ; MUL call
          DEC             
          PUSH
          LD    &3
          PUSH
          LD    &3
          PUSH
          CALL  MUL
          RET
BASE:     LD    &2
          ADD   &1
          ST    FADDR
          LD    &1
          DEC
          ST    IFACT
          CLA
          INC
          ST    -(FADDR)
BASEREP:  CLA
          ST    -(FADDR)
          LOOP  IFACT
          JUMP  BASEREP
          RET
OFW:      LD    &2
          ADD   &1
          ST    FADDR
          LD    &1
          ST    IFACT
OFWREP:   CLA
          ST    -(FADDR)
          LOOP  IFACT
          JUMP  OFWREP
          RET
FADDR:    NOP             ; keeps current result's word address from stack
FIVAR:    NOP             ; i-variable for iteration over result

; ПЕРЕРАБОТАТЬ В СООТВЕТСТВИИ С СИГНАТУРОЙ
MUL:      LD    &1        ; MUL(uint16_t arg1, uint16_t arg2[], uint16_t arg2_size, uint16_t* result)
          ST    LOOPVAR
VARREP:   ASL
          LOOP  LOOPVAR
          JUMP  VARREP
          ST    MULITER
          LD    &3
          ST    MULTIPLE
MULJUMP:  LD    MULTIPLE  ; load 16-bit multiple
          ROR
          BCC   SHFT      ; check its least bit
          LD    &2
          ST    MADDR
          LD    STCKLD
          ADD   RESWRDS
          ST    CMDLD
          LD    &1
          DEC
          ST    MIVAR
          CLC
CMDLD:    NOP             ; load current word of multiple from stack
          ADC   (MADDR)
          ST    -(MADDR)
          LD    CMDLD
          DEC
          ST    CMDLD
          LOOP  MIVAR
          JUMP  CMDLD
SHFT:     LD    &2        ; shift-right resulting words
          ST    MADDR
          LD    &1
          ST    MIVAR
SHFTREP:  LD    (MADDR)+
          ROR
          ST    (MADDR)
          LOOP  MIVAR
          JUMP  SHFTREP
          LOOP  MITER     ; main multiplication loop over MULTIPLE's bits 
          JUMP  MULJUMP
          RET
MADDR:    NOP             ; points to current word of result
MULTIPLE: NOP             ; least 16-bit multiple for iteration
MITER:    NOP             ; iter variable for multiplication (16 in total)
MIVAR:    NOP             ; i-variable for iteration over result
LOOPVAR:  NOP
STCKLD:   LD    &2        ; loads ending word of multiple from stack