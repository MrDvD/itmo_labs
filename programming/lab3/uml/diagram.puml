@startuml name
Being <|-- LittleGuy
ICapitalisticActive <|.. LittleGuy : implements
ICapitalisticActive <|.. ICapitalisticPassive : sell()
ICapitalisticPassive <|.. ICapitalisticActive : getOwner()
ISociable <|.. LittleGuy : implements

Being <|.. Container : eatIterative()
Being <|.. Eatable : eat()

object ponchik
object piluylkin
object neznayka

LittleGuy <|-- ponchik
LittleGuy <|-- piluylkin
LittleGuy <|-- neznayka

object borscht
object porridge
object salt
Eatable <|-- borscht
Eatable <|-- porridge
Eatable <|-- salt

ICapitalisticPassive <|.. Container : implements
ICapitalisticPassive <|.. Eatable : implements

IMeasurable <|.. Eatable : implements
IMeasurable <|.. Container : implements
IWeightable <|.. Being : implements

Container <|-- Bowl
Container <|-- Table
Container <|-- Rocket
Container <|.. IMeasurable : addItem()
Container <|.. IWeightable : addItem()

ILocatable <|.. Rocket : implements
ILocatable <|.. Being : implements
Place <|.. ILocatable : getLocation()

Place <|-- Moon
Moon <|-- Underground
Moon <|-- LosPaganos
Moon <|-- Cave

State <|.. Being : refers

SocialOrganization <|.. SocialStatus : refers
ICapitalisticActive <|.. Duty : setDuty()
ISociable <|.. SocialStatus : addSocialStatus()

class LittleGuy {
   -dutyName: String
   +LittleGuy(name)
}

enum State {
   NORMAL
   SHOCKED
   UNCONSCIOUS
}

interface ICapitalisticPassive {
   DEFAULT_COST: float
   +ICapitalisticActive getOwner()
   +float cost()
   +void sell()
}

interface ICapitalisticActive {
   +float getBalance()
   #void setBalace(balance: float)
   +String getDuty()
   +void setDuty(duty: Duty)
   +void work()
   +void sell(obj: ICapitalisticPassive)
   +void buy(obj: ICapitalisticPassive)
}

interface ISociable {
   +void say(text: String)
   +void addSocialStatus(obj: SocialStatus)
   +ArrayList<SocialStatus> getSocialStatuses()
}

abstract class Being {
   -name: String
   -type: String
   -hunger: byte
   -location: Place
   -state: State
   +Being()
   +Being(name: String, type: String)
   +void eat(obj: Eatable)
   +void eat(obj: Eatable, eatingSpeed: byte)
   +void eatIterative(obj: Container)
   +void eatIterative(obj: Container, eatingSpeed: byte)
   +void setState(state: State)
   +void force()
   #void addHunger(byte hunger)
   #void subHunger(byte hunger)
   ' to do something
}

class Eatable << (R,#FF7700) >> {
   -name: String
   -saturation: byte
   -cost: float
   +Eatable(name: String, saturation: byte)
   +Eatable(name: String, saturation: byte, cost: float)
}

class Duty << (R,#FF7700) >> {
   -name: String
   -wage: float
   -days: int
   +Duty(name: String, wage: float, days: int)
}

class SocialStatus << (R,#FF7700) >> {
   -name: String
   -organization: SocialOrganization
   +SocialStatus(name: String, organization: SocialOrganization)
}

class SocialOrganization << (R,#FF7700) >> {
   -name: String
   +SocialOrganization(name: String)
}

abstract class Container {
   -spaceLeft: float
   +Container()
   +Container(name)
   +void addItem(obj: IMeasurable)
   +void addUser(obj: IWeightable)
   +List<IMeasurable> getItemList()
   +List<IWeightable> getUserList()
   +void delItem(obj: IMeasurable)
   +void delUser(obj: IWeightable)
   +float getSize()
   +void empty()
}

class Table {
   +Table()
}

class Bowl {
   +Bowl()
}

class Rocket {
   +Rocket()
}

class Moon {
   +Moon()
}

class LosPaganos {
   +LosPaganos()
}

class Underground {
   +Underground()
}

class Cave {
   +Cave()
}

abstract class Place {
   -name: String
   -List<> visitors: Being
   +Place(name)
   +String getParent()
   +String getAddress()
   +List<> getVisitors()
}

interface IMeasurable {
   +boolean canFit(size: float)
}

interface IWeightable {
   +boolean canWithstand(weight: float)
}

interface ILocatable {
   +Place getLocation()
   +void setLocation(obj: Location)
}
@enduml

' make size attribute to define whether the item can be keepable in the Container or not